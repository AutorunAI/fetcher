{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["const EXCEPTION = {\n\tRESPONSE: \"[Fetcher]: Network request failed\",\n\tJSON: \"[Fetcher]: Response is not valid JSON\",\n} as const\n\ntype FetcherBodyLessInit = Omit<RequestInit, \"method\" | \"body\">\ntype FetcherBodyFullInit = FetcherBodyLessInit & { data: unknown }\n\ntype FetcherBodyLessOptions<TUrl = string> = { url: TUrl } & FetcherBodyLessInit\ntype FetcherBodyFullOptions<TUrl = string> = { url: TUrl } & FetcherBodyFullInit\ntype FetcherOptions<TUrl = string> = { url: TUrl } & (FetcherBodyLessInit | FetcherBodyFullInit)\n\ntype FetcherConfig<TUrl = string> = {\n\t/** Url prefix that is added to each url the fetcher calls */\n\tbaseUrl?: string\n\n\t/** Default options to be passed to fetch on request. Specific default properties are overridden when passed on request as well. */\n\tfetch?: Omit<FetcherOptions<TUrl>, \"url\" | \"method\">\n\n\t/** Handlers for fetcher events */\n\thooks?: {\n\t\t/**\n\t\t * Executed before a fetch request is made, allowing modification of request params\n\t\t * @param url - The URL being passed to fetch\n\t\t * @param init - The request init object being passed to fetch\n\t\t * @returns Modified fetch parameters tuple [url, init]\n\t\t */\n\t\tonBeforeRequest?: (url: string, init: RequestInit) => [string, RequestInit]\n\n\t\t/**\n\t\t * Handles errors that occur during the fetch call\n\t\t * @param url - The URL that failed\n\t\t * @param init - The request init object that failed\n\t\t * @returns Either void (use default error) or never (throw custom error)\n\t\t */\n\t\tonFetchResourceError?:\n\t\t\t| ((url: string, init: RequestInit) => never)\n\t\t\t| ((url: string, init: RequestInit) => void)\n\n\t\t/**\n\t\t * Handles errors that occur when parsing the JSON response\n\t\t * @param props - Object containing the fetch Response\n\t\t * @returns Either void (use default error) or never (throw custom error)\n\t\t */\n\t\tonJsonTransformError?:\n\t\t\t| ((props: { response: Response }) => never)\n\t\t\t| ((props: { response: Response }) => void)\n\n\t\t/**\n\t\t * Handles responses with non-2xx status codes\n\t\t * @param props - Object containing the Response and parsed JSON data\n\t\t * @returns Either void (use default error) or never (throw custom error)\n\t\t */\n\t\tonResponseNotOkError?:\n\t\t\t| ((props: { response: Response; data: unknown }) => never)\n\t\t\t| ((props: { response: Response; data: unknown }) => void)\n\n\t\t/**\n\t\t * Executed after a successful response with parsed JSON\n\t\t * @param props - Object containing the Response and parsed JSON data\n\t\t * @returns Either void (continue) or never (throw custom error)\n\t\t */\n\t\tonResponseOk?:\n\t\t\t| ((props: { response: Response; data: unknown }) => never)\n\t\t\t| ((props: { response: Response; data: unknown }) => void)\n\t}\n}\n\ntype FetcherHttpMethod = \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\"\n\n/* biome-ignore lint/suspicious/noExplicitAny: perf optimization, use same empty object on nullable prop */\nconst EMPTY_RECORD: Record<any, any> = Object.freeze({})\n\n/** Creates a powerful type-safe fetch wrapper instance */\nconst createFetcher = <TUrl = string>(\n\t{\n\t\tbaseUrl,\n\t\thooks,\n\t\tfetch: fetchOptions = EMPTY_RECORD as Omit<FetcherOptions<TUrl>, \"method\" | \"url\">,\n\t\t...defaultOptions\n\t}: FetcherConfig<TUrl> = EMPTY_RECORD as FetcherConfig<TUrl>,\n) => {\n\tconst {\n\t\tonBeforeRequest,\n\t\tonFetchResourceError,\n\t\tonJsonTransformError,\n\t\tonResponseNotOkError,\n\t\tonResponseOk,\n\t} = hooks ?? (EMPTY_RECORD as NonNullable<FetcherConfig<TUrl>[\"hooks\"]>)\n\n\tconst buildRequest = (\n\t\tmethod: FetcherHttpMethod,\n\t\t{ url, ...options }: FetcherOptions<TUrl>,\n\t): [string, RequestInit] => {\n\t\tconst requestUrl = baseUrl ? `${baseUrl}${url}` : (url as string)\n\t\tconst requestInit = {\n\t\t\tmethod,\n\t\t\t...defaultOptions,\n\t\t\t...fetchOptions,\n\t\t\t...options,\n\t\t} as RequestInit\n\n\t\tif (onBeforeRequest) {\n\t\t\treturn onBeforeRequest(requestUrl, requestInit)\n\t\t}\n\n\t\treturn [requestUrl, requestInit]\n\t}\n\n\tconst request = (method: FetcherHttpMethod, options: FetcherOptions<TUrl>) => ({\n\t\tjson: async <T>(): Promise<{ response: Response; data: T }> => {\n\t\t\tconst headers = {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t} as const\n\n\t\t\tconst mergedOptions =\n\t\t\t\t\"data\" in options && options.data\n\t\t\t\t\t? { ...options, body: JSON.stringify(options.data), headers }\n\t\t\t\t\t: { ...options, headers }\n\n\t\t\tconst [requestUrl, requestInit] = buildRequest(method, mergedOptions)\n\n\t\t\tconst response = await fetch(requestUrl, requestInit).catch(() => {\n\t\t\t\tif (onFetchResourceError) {\n\t\t\t\t\tonFetchResourceError(requestUrl, requestInit)\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(EXCEPTION.RESPONSE)\n\t\t\t})\n\n\t\t\tconst data = await response.json().catch(() => {\n\t\t\t\tif (onJsonTransformError) {\n\t\t\t\t\tonJsonTransformError({ response })\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(EXCEPTION.JSON)\n\t\t\t})\n\n\t\t\tif (!response.ok) {\n\t\t\t\tif (onResponseNotOkError) {\n\t\t\t\t\tonResponseNotOkError({ response, data })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (onResponseOk) {\n\t\t\t\tonResponseOk({ response, data })\n\t\t\t}\n\n\t\t\treturn { response, data: data as T }\n\t\t},\n\t})\n\n\treturn {\n\t\tget: (options: FetcherBodyLessOptions<TUrl>) => request(\"GET\", options),\n\t\tpost: (options: FetcherBodyFullOptions<TUrl>) => request(\"POST\", options),\n\t\tput: (options: FetcherBodyFullOptions<TUrl>) => request(\"PUT\", options),\n\t\tpatch: (options: FetcherBodyFullOptions<TUrl>) => request(\"PATCH\", options),\n\t\tdelete: (options: FetcherBodyLessOptions<TUrl>) => request(\"DELETE\", options),\n\t}\n}\n\nexport { createFetcher, EXCEPTION }\nexport type {\n\tFetcherBodyFullInit,\n\tFetcherBodyFullOptions,\n\tFetcherBodyLessInit,\n\tFetcherBodyLessOptions,\n\tFetcherConfig,\n\tFetcherHttpMethod,\n\tFetcherOptions,\n}\nexport default createFetcher\n"],"names":["EXCEPTION","RESPONSE","JSON","EMPTY_RECORD","Object","freeze","createFetcher","baseUrl","hooks","fetch","fetchOptions","defaultOptions","onBeforeRequest","onFetchResourceError","onJsonTransformError","onResponseNotOkError","onResponseOk","buildRequest","method","url","options","requestUrl","requestInit","request","json","headers","data","body","stringify","response","catch","Error","ok","get","post","put","patch","delete"],"mappings":"AAAA,IAAMA,EAAY,CACjBC,SAAU,oCACVC,KAAM,uCACP,EAoEMC,EAAiCC,OAAOC,MAAM,CAAC,IAG/CC,EAAgB,CACrB,CACCC,QAAAA,CAAO,CACPC,MAAAA,CAAK,CACLC,MAAOC,EAAeP,CAA4D,CAClF,GAAGQ,EACkB,CAAGR,CAAmC,IAE5D,GAAM,CACLS,gBAAAA,CAAe,CACfC,qBAAAA,CAAoB,CACpBC,qBAAAA,CAAoB,CACpBC,qBAAAA,CAAoB,CACpBC,aAAAA,CAAY,CACZ,CAAGR,GAAUL,EAERc,EAAe,CACpBC,EACA,CAAEC,IAAAA,CAAG,CAAE,GAAGC,EAA+B,IAEzC,IAAMC,EAAad,EAAU,CAAGA,EAAAA,EAAAA,EAAUY,GAAK,CAAIA,EAC7CG,EAAc,CACnBJ,OAAAA,EACA,GAAGP,CAAc,CACjB,GAAGD,CAAY,CACf,GAAGU,CAAAA,AACJ,SAEA,AAAIR,EACIA,EAAgBS,EAAYC,GAG7B,CAACD,EAAYC,EAAY,AACjC,EAEMC,EAAU,CAACL,EAA2BE,IAAmC,CAAA,CAC9EI,KAAM,UACL,IAAMC,EAAU,CACf,eAAgB,kBACjB,EAOM,CAACJ,EAAYC,EAAY,CAAGL,EAAaC,EAJ9C,SAAUE,GAAWA,EAAQM,IAAI,CAC9B,CAAE,GAAGN,CAAO,CAAEO,KAAMzB,KAAK0B,SAAS,CAACR,EAAQM,IAAI,EAAGD,QAAAA,GAClD,CAAE,GAAGL,CAAO,CAAEK,QAAAA,CAAQ,GAIpBI,EAAW,MAAMpB,MAAMY,EAAYC,GAAaQ,KAAK,CAAC,KAK3D,MAJIjB,GACHA,EAAqBQ,EAAYC,GAG5B,AAAIS,MAAM/B,EAAUC,QAAQ,CACnC,GAEMyB,EAAO,MAAMG,EAASL,IAAI,GAAGM,KAAK,CAAC,KAKxC,MAJIhB,GACHA,EAAqB,CAAEe,SAAAA,CAAS,GAG3B,AAAIE,MAAM/B,EAAUE,IAAI,CAC/B,GAYA,MAVI,CAAC2B,EAASG,EAAE,EACXjB,GACHA,EAAqB,CAAEc,SAAAA,EAAUH,KAAAA,CAAK,GAIpCV,GACHA,EAAa,CAAEa,SAAAA,EAAUH,KAAAA,CAAK,GAGxB,CAAEG,SAAAA,EAAUH,KAAMA,CAAU,CACpC,IAGD,MAAO,CACNO,IAAK,AAACb,GAA0CG,EAAQ,MAAOH,GAC/Dc,KAAM,AAACd,GAA0CG,EAAQ,OAAQH,GACjEe,IAAK,AAACf,GAA0CG,EAAQ,MAAOH,GAC/DgB,MAAO,AAAChB,GAA0CG,EAAQ,QAASH,GACnEiB,OAAQ,AAACjB,GAA0CG,EAAQ,SAAUH,EACtE,CACD"}